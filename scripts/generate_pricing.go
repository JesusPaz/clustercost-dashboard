package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"sort"
	"strconv"
	"time"
)

const (
	// AWS Price List API (Bulk)
	// Region Index: https://pricing.us-east-1.amazonaws.com/offers/v1.0/aws/AmazonEC2/current/region_index.json
	baseUrl        = "https://pricing.us-east-1.amazonaws.com"
	regionIndexUrl = baseUrl + "/offers/v1.0/aws/AmazonEC2/current/region_index.json"
)

// Target regions to keep file size manageable for this MVP.
// We can expand this list or make it a flag.
var targetRegions = []string{
	// US
	"us-east-1", "us-east-2",
	"us-west-1", "us-west-2",
	// Europe
	"eu-central-1", "eu-west-1", "eu-west-2", "eu-north-1", "eu-south-1", "eu-west-3",
	// Asia Pacific
	"ap-southeast-1", "ap-southeast-2", "ap-northeast-1", "ap-northeast-2", "ap-south-1",
	// Other
	"ca-central-1", "sa-east-1",
}

type RegionIndex struct {
	Regions map[string]RegionEntry `json:"regions"`
}

type RegionEntry struct {
	RegionCode        string `json:"regionCode"`
	CurrentVersionUrl string `json:"currentVersionUrl"`
}

type PriceList struct {
	Products map[string]Product                    `json:"products"`
	Terms    map[string]map[string]map[string]Term `json:"terms"` // OnDemand -> SKU -> OfferTermCode -> Term
}

type Product struct {
	Sku           string            `json:"sku"`
	ProductFamily string            `json:"productFamily"`
	Attributes    map[string]string `json:"attributes"`
}

type Term struct {
	PriceDimensions map[string]PriceDimension `json:"priceDimensions"`
}

type PriceDimension struct {
	PricePerUnit map[string]string `json:"pricePerUnit"`
}

func main() {
	fmt.Println("Generating pricing data...")

	// 1. Fetch Region Index
	fmt.Printf("Fetching region index from %s\n", regionIndexUrl)
	resp, err := http.Get(regionIndexUrl)
	if err != nil {
		panic(err)
	}
	defer func() { _ = resp.Body.Close() }()

	var index RegionIndex
	if err := json.NewDecoder(resp.Body).Decode(&index); err != nil {
		panic(err)
	}

	prices := make(map[string]float64)

	// 2. Iterate Regions
	for _, region := range targetRegions {
		entry, ok := index.Regions[region]
		if !ok {
			fmt.Printf("Warning: Region %s not found in index\n", region)
			continue
		}

		fullUrl := baseUrl + entry.CurrentVersionUrl
		fmt.Printf("Processing %s (%s)...\n", region, fullUrl)

		regionPrices, err := processRegion(fullUrl)
		if err != nil {
			panic(err)
		}

		for k, v := range regionPrices {
			// Key format: "region|instanceType"
			key := fmt.Sprintf("%s|%s", region, k)
			prices[key] = v
		}
	}

	// 3. Generate Go Code
	if err := generateGoFile(prices); err != nil {
		panic(err)
	}

	fmt.Println("Done!")
}

func processRegion(url string) (map[string]float64, error) {
	resp, err := http.Get(url) // #nosec G107
	if err != nil {
		return nil, err
	}
	defer func() { _ = resp.Body.Close() }()

	var list PriceList
	// The file can be large, but for a single region it's manageable (tens of MBs)
	if err := json.NewDecoder(resp.Body).Decode(&list); err != nil {
		return nil, err
	}

	result := make(map[string]float64)

	for sku, product := range list.Products {
		attrs := product.Attributes

		// Filter
		if attrs["servicecode"] != "AmazonEC2" {
			continue
		} // explicit check (though map is filtered by URL)
		if attrs["operatingSystem"] != "Linux" {
			continue
		}
		if attrs["tenancy"] != "Shared" {
			continue
		}
		if attrs["capacitystatus"] != "Used" {
			continue
		}
		if attrs["preInstalledSw"] != "NA" {
			continue
		}

		instanceType := attrs["instanceType"]
		if instanceType == "" {
			continue
		}

		// Find Price
		// Terms -> OnDemand -> SKU -> ...
		onDemandTerms, ok := list.Terms["OnDemand"][sku]
		if !ok {
			continue
		}

		for _, term := range onDemandTerms {
			for _, dim := range term.PriceDimensions {
				if costStr, ok := dim.PricePerUnit["USD"]; ok {
					cost, err := strconv.ParseFloat(costStr, 64)
					if err == nil && cost > 0 {
						result[instanceType] = cost
						// We take the first valid price found for this SKU
						// (usually there's only one OnDemand price per SKU matching filters)
						goto NextProduct
					}
				}
			}
		}

	NextProduct:
	}

	fmt.Printf("  Found %d instance types for region\n", len(result))
	return result, nil
}

func generateGoFile(prices map[string]float64) error {
	f, err := os.Create("internal/pricing/data.go")
	if err != nil {
		return err
	}
	defer func() { _ = f.Close() }()

	keys := make([]string, 0, len(prices))
	for k := range prices {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	_, _ = fmt.Fprintf(f, "// Code generated by scripts/generate_pricing.go; DO NOT EDIT.\n")
	_, _ = fmt.Fprintf(f, "// Generated at %s\n", time.Now().Format(time.RFC3339))
	_, _ = fmt.Fprintf(f, "package pricing\n\n")
	_, _ = fmt.Fprintf(f, "var InstancePrices = map[string]float64{\n")

	for _, k := range keys {
		_, _ = fmt.Fprintf(f, "\t%q: %f,\n", k, prices[k])
	}

	_, _ = fmt.Fprintf(f, "}\n")
	return nil
}
